# Проект 0. Угадай число

## Оглавление
[1. Описание проекта](.README.md#Описание-проекта)

[2. Какой кейс решаем?](.README.md#Какой-кейс-решаем)

[3. Краткая информация о данных](.README.md#Краткая-информация-о-данных)

[4. Этапы работы над проектом](.README.md#Этапы-работы-над-проектом)

[5. Результат](.README.md#Результат)

[6. Выводы](.README.md#Выводы)

### Описание проекта
Угадать загаданное компьютером число за  число попыток **меньше 20**.

:arrow_up:[к оглавлению](_)


### Какой кейс решаем?
Нужно написать программу, которая угадывает число за число попыток **меньше 20**.

**Условия соревнования:**
- Компьютер загадывает целое число от 0 до 100, и нам его нужно угадать. Под «угадать», подразумевается «написать программу, которая угадывает число».
- Алгоритм учитывает информацию о том, больше ли случайное число или меньше нужного нам.

**Метрика качества**
Результаты оцениваются по среднему количеству попыток при 10000 повторений

**Что практикуем**
Учимся писать хороший код на python


### Краткая информация о данных
Предаставлен архив с базовым решением задачи.
**В архиве**:
- Ноутбук `game.ipynb` для демонстрации результата работы разработанной функции
- Файл `game.py` с примером случайного угадывания числа
- Файл `game_v2.py` с примером функции случайного угадывания числа и функции подсчета среднего количества угадываний
- Файл `README.md` с шаблоном описания работы программы

:arrow_up:[к оглавлению](.README.md#Оглавление)


### Этапы работы над проектом
1) Фиксируем зависимости в файле `requirements.txt`.
2) Реализуем функцию бинарного поиска для угадывания слуайного числа в файле `game_v3.py`.
3) Тестируем функцию в ноутбуке `game.ipynb`.
4) Описываем всю информацию о проекте и результатах в файле `README.md`.
5) Отправляем все рабочие файлы в `GitHub`.

:arrow_up:[к оглавлению](.README.md#Оглавление)


### Результаты:
Разработанная функция, которая использует алгоритм `бинарного поиска`, находит случайное число в среднем за **`5 попыток`** из `10000 измерений`.

:arrow_up:[к оглавлению](.README.md#Оглавление)


### Выводы:
Временная сложность алгоритма бинарного поиска равна **`O(log2 n)`**, что при n = 100 позволяет достигнуть необходимого результата: количество попыток значительно меньше 20.

:arrow_up:[к оглавлению](.README.md#Оглавление)


Если информация по этому проекту покажется вам интересной или полезной, то я буду очень вам благодарен, если отметите репозиторий и профиль ⭐️⭐️⭐️-дами
